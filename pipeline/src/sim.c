/********************************************************************************
 * File Name    :       sim.c
 * Description  :       This file contains all the code for C-simulator of MIPS32
 *                      ISA
 * Author       :       Waqar Ali       (wali@ku.edu)
 * *****************************************************************************/

#include <stdio.h>
#include "shell.h"
#include "sim.h"

/*
 * ==========================================================================
 * Function Definitios
 * ==========================================================================
 */

void process_instruction()
{
    uint8_t status = SUCCESS;

    /* Step-1 : Fetch Instruction */
    status = instruction_fetch();

    if (status == SUCCESS) {
        /* Step-2 : Decode Instruction */
        status = instruction_decode();
    }

    if (status == SUCCESS) {
        /* Step-3 : Instruction Execute */
        status = instruction_execute();
    }

    if (status == SUCCESS) {
        /* Step-4 : Memory Write */
        status = memory_write();
    }

    if (status == SUCCESS) {
        /* Step-5 : Write Back */
        status = write_back();
    }

    SIM_DEBUG(printf("\nStatus : %s\n\n", (status? "FAILURE":"SUCCESS")));

    return;
}

/*
 * instruction_fetch
 * Models the instruction fetch stage of single cycle MIPS processor
 */
uint8_t instruction_fetch(void)
{
    uint8_t status = SUCCESS;

    SIM_DEBUG(printf("\nCurrent PC : 0x%x\n", CURRENT_STATE.PC));

    instruction = mem_read_32(CURRENT_STATE.PC);
    
    SIM_DEBUG(printf("Got the following instruction to process : 0x%x\n", instruction));
    
    /* Pseudo Step 1.1 : Calculate PC + 4 using alu as an adder */
    pc_adder.input_1    = CURRENT_STATE.PC;
    pc_adder.input_2    = (int32_t)4;
    pc_adder.alu_ctl    = ALU_ADD;
    
    status = alu_process(&pc_adder, &w_pc_adder, &w_ground);

    return (status);
}

/*
 * instruction_decode
 * Models the instruction decode stage of single cycle MIPS processor
 */
uint8_t instruction_decode(void)
{
    uint8_t status = SUCCESS;

    opcode      = GET_INST_OPCODE(instruction);
    rs          = GET_INST_RS(instruction);
    rt          = GET_INST_RT(instruction);
    rd          = GET_INST_RD(instruction);
    shamt       = GET_INST_SHAMT(instruction);

    jump        = GET_INST_JUMP(instruction);

    /* FIXME: Because the assembler in use to generate hex assumes the text start at 0x0 always,
              we have to manually add the offset of .text region to the jump address in order to
              have valid PC value in case of jump instruction */
    jump        = jump + (MEM_TEXT_START >> 2);

    funct       = GET_INST_FUNCT(instruction);
    immediate   = GET_INST_IMMD(instruction);

    SIM_DEBUG(printf("opcode : 0x%.2x (%.2d) | rs : 0x%.2x (%.2d) | rt : 0x%.2x (%.2d) | rd : 0x%.2x (%.2d) | shamt : 0x%.2x (%.2d) | funct : 0x%.2x (%.2d) | immediate : 0x%.4x (%.5d) | jump : 0x%.6x (%.8d)\n", opcode, opcode, rs, rs, rt, rt, rd, rd, shamt, shamt, funct, funct, immediate, immediate, jump, jump));

    /* Write the opcode to the input of control-unit */
    ctl_unit.opcode = opcode;
    ctl_unit.funct  = funct;

    /* Generate control signals */
    status = generate_control_signals();
    
    /* Output control-signals generated by the control-unit */
    SIM_DEBUG(control_debug());

    /* Proceed only if the previous stages were successful */
    if (status == SUCCESS) {
        /* Write the input values to the sign-extendor  */
        extend_immd.input               = (int16_t)immediate;

        /* Execute the sign-extension process */
        sign_extend_process();
    }

    if (status == SUCCESS) {
        /* Calculate jump-shift using the jump field */
        jump_shift.input_1              = (int32_t)2;
        jump_shift.input_2              = jump;
        jump_shift.alu_ctl              = ALU_SLL;

        status = alu_process(&jump_shift, &w_jump_shift, &w_ground);
    }
    
    if (status == SUCCESS) {
        /* FIXME: There should be a better way of doing this */
        w_jump_shift                    = (w_jump_shift & 0x0FFFFFFF) | (w_pc_adder & 0xF0000000);

        /* Calculate the immediate shift using the sign-extended immediate value */
        immd_shift.input_1              = (int32_t)2;
        immd_shift.input_2              = w_signext_immd;
        immd_shift.alu_ctl              = ALU_SLL;

        /* Execute the ALU process */
        status = alu_process(&immd_shift, &w_immd_shift, &w_ground); 
    }

    if (status == SUCCESS) {
        /* Calculate the branch-address */
        branch_adder.input_1            = w_pc_adder;
        branch_adder.input_2            = w_immd_shift;
        branch_adder.alu_ctl            = ALU_ADD;

        /* Execute the ALU process */
        status = alu_process(&branch_adder, &w_branch_adder, &w_ground);
    }   

    if (status == SUCCESS) {
        /* Write the inputs to the alu-control unit */
        alu_ctl.opcode                  = opcode;
        alu_ctl.funct                   = funct;    

        /* Execute the alu-control process */
        status = alu_control_process(&alu_ctl, &w_alu_ctl_in);
        SIM_DEBUG(printf("\nalu_ctl->opcode : 0x%.8x | %d\n", alu_ctl.opcode, alu_ctl.opcode));
        SIM_DEBUG(printf("alu_ctl->funct  : 0x%.8x | %d\n", alu_ctl.funct, alu_ctl.funct));
        SIM_DEBUG(printf("w_alu_ctl_in    : 0x%.8x | %d\n", w_alu_ctl_in, w_alu_ctl_in));
    }

    if (status == SUCCESS) {
        /* Write the required data to the input of reg_file_in mux */
        mux_reg_file_in.input_0         = rt;
        mux_reg_file_in.input_1         = rd;
        mux_reg_file_in.control_signal  = w_ctl_reg_dst; 

        /* Execute the multiplexor process */
        status = multiplexor_process(&mux_reg_file_in, &w_mux_reg_file_in);
    }

    if (status == SUCCESS) {
        /* Write the input values of register file */
        reg_file.read_reg_1             = rs;
        reg_file.read_reg_2             = rt;
        reg_file.write_reg              = w_mux_reg_file_in;
        reg_file.ctl_reg_write          = w_ctl_reg_write;

        /* Execute the register file process */
        status = reg_file_process((uint8_t)CLK_HI);
    }

    if (status == SUCCESS) {
        /* Write the required data to the input of alu_in mux_1 */
        mux_alu_in_1.input_0            = w_reg_file_data_1;
        mux_alu_in_1.input_1            = shamt;
        mux_alu_in_1.control_signal     = w_ctl_alu_src_1;

        /* Execute the multiplexor process for alu_in mux_1 */
        status = multiplexor_process(&mux_alu_in_1, &w_mux_alu_in_1);

        //printf("mux_alu_in_1->ctl    : 0x%x\n", mux_alu_in_1.control_signal);
        //printf("w_mux_alu_in_1       : 0x%x\n", w_mux_alu_in_1);
    }

    if (status == SUCCESS) {
        //printf("w_signext_immd  : 0x%x\n", w_signext_immd);

        /* Write the required data to the input of alu_in mux_2 */
        mux_alu_in_2.input_0            = w_reg_file_data_2;
        mux_alu_in_2.input_1            = w_signext_immd;
        mux_alu_in_2.control_signal     = w_ctl_alu_src_2;

        /* Execute the multiplexor process for alu_in mux_2 */
        status = multiplexor_process(&mux_alu_in_2, &w_mux_alu_in_2);

        //printf("mux_alu_in_2->ctl    : 0x%x\n", mux_alu_in_2.control_signal);
        //printf("w_mux_alu_in_2       : 0x%x\n", w_mux_alu_in_2);
    }

    if (status == SUCCESS) {
        /* Write input data for ALU */
        alu.input_1                     = w_mux_alu_in_1;
        alu.input_2                     = w_mux_alu_in_2;
        alu.alu_ctl                     = w_alu_ctl_in;                 

        SIM_DEBUG(printf("\nalu->input1     : 0x%.8x | %d\n", alu.input_1, alu.input_1));
        SIM_DEBUG(printf("alu->input2     : 0x%.8x | %d\n", alu.input_2, alu.input_2));
        SIM_DEBUG(printf("alu->ctl        : 0x%.8x | %d\n", alu.alu_ctl, alu.alu_ctl));
     }

    return (status);
}

/*
 * instruction_execute
 * Models the instruction execute stage of MIPS processor
 */
uint8_t instruction_execute(void)
{
    uint8_t status = SUCCESS;

    /* Execute the alu process */
    status = alu_process(&alu, &w_alu_out_1, &w_zero);

    SIM_DEBUG(printf("\nalu->output     : 0x%.8x | %d\n", w_alu_out_1, w_alu_out_1));
    SIM_DEBUG(printf("alu->zero       : 0x%.8x | %d\n", w_zero, w_zero));

    /* Now the branch decision can be taken */
    if (status == SUCCESS) {
        /* FIXME: This is not in accordance with the module overall 
           Take the branch decision */
        if (w_ctl_beq == TRUE && w_ctl_bne == FALSE && w_zero == TRUE) {
            w_branch_control = TRUE;
            status = SUCCESS;
        } else if (w_ctl_beq == FALSE && w_ctl_bne == TRUE && w_zero == FALSE) {
            w_branch_control = TRUE;
            status = SUCCESS;
        } else if (w_ctl_beq == TRUE && w_ctl_bne == TRUE) {
            printf("[ERR] Fatal Error in branch controller\n");
            status = FAILURE;
        } else {
            w_branch_control = FALSE;
            status = SUCCESS;
        }
    }

    /* Execute the multiplexor process to select between branch and pc + 4 */
    if (status == SUCCESS) {
        mux_beq.input_0                 = w_pc_adder; 
        mux_beq.input_1                 = w_branch_adder;
        mux_beq.control_signal          = (uint8_t)w_branch_control;

        status = multiplexor_process(&mux_beq, &w_mux_beq);
    }

    /* Execute the final multiplexor process to select the next-pc value */
    if (status == SUCCESS) {
        mux_next_pc.input_0             = w_mux_beq;
        mux_next_pc.input_1             = w_jump_shift;
        mux_next_pc.control_signal      = w_ctl_jump;

        status = multiplexor_process(&mux_next_pc, &w_mux_next_pc);
    }

    /* Finally assign PC its next value */
    if (status == SUCCESS) {
        SIM_DEBUG(printf("\nNext PC : 0x%x\n", w_mux_next_pc));
        NEXT_STATE.PC                = w_mux_next_pc;
    }

    return (status);
}

/*
 * memory_write
 * Models the memory write stage of MIPS processor
 */
uint8_t memory_write(void)
{
    uint8_t status = SUCCESS;

    /* Write the data to the input of memory-unit */
    memory.address          = w_alu_out_1;
    memory.write_data       = w_reg_file_data_2;
    memory.ctl_mem_read     = w_ctl_mem_read;
    memory.ctl_mem_write    = w_ctl_mem_write;

    /* Execute the memory process */
    status = memory_process(&memory, &w_mem_out);

    return (status);
}

/*
 * write_back
 * Models the write-back stage of MIPS processor in which data is written
 * back to register file 
 */
uint8_t write_back(void)
{
    uint8_t status = SUCCESS;

    /* Write the data to the input mux of register file data input */
    mux_reg_file_data.input_0           = w_alu_out_1;
    mux_reg_file_data.input_1           = w_mem_out;
    mux_reg_file_data.control_signal    = w_ctl_mem_to_reg;

    /* Execute the mux process to make data selection */
    status = multiplexor_process(&mux_reg_file_data, &w_mux_reg_file_write_data);

    if (status == SUCCESS) {
        /* Execute the register-file process again to write back the data */
        reg_file.write_data             = w_mux_reg_file_write_data;

        status = reg_file_process((uint8_t)CLK_LO);
    }

    return (status);
}
    
/*
 * generate_control_signals
 * This is a helper function which models the working of the control unit
 * in single cycle MIPS processor
 */
uint8_t generate_control_signals(void)
{
    uint8_t status = SUCCESS;

    switch(ctl_unit.opcode)
    {
        case OP_RTYPE:
            ctl_unit.reg_dst    = 1;

            /* In case of R-type shift instructions, alu-input1 needs to come
               from shift-amount field of instruction */
            switch (ctl_unit.funct)
            {
                case FUNCT_SLL:
                case FUNCT_SRL:
                case FUNCT_SRA:
                    ctl_unit.alu_src_1 = 1;
                    break;
                
                default:
                    ctl_unit.alu_src_1 = 0;
                    break;
            }

            ctl_unit.alu_src_2  = 0;
            ctl_unit.mem_to_reg = 0;
            ctl_unit.reg_write  = 1;
            ctl_unit.mem_read   = 0;
            ctl_unit.mem_write  = 0;
            ctl_unit.beq        = 0;
            ctl_unit.bne        = 0;
            ctl_unit.jump       = 0;
            break;

        case OP_ADDI:
        case OP_ADDIU:
        case OP_SLTI:
        case OP_SLTIU:
        case OP_ANDI:
        case OP_ORI:
        case OP_XORI:
        case OP_LUI:
            ctl_unit.reg_dst    = 0;
            ctl_unit.alu_src_1  = 0;
            ctl_unit.alu_src_2  = 1;
            ctl_unit.mem_to_reg = 0;
            ctl_unit.reg_write  = 1;
            ctl_unit.mem_read   = 0;
            ctl_unit.mem_write  = 0;
            ctl_unit.beq        = 0;
            ctl_unit.bne        = 0;
            ctl_unit.jump       = 0;
            break;

        case OP_JUMP:
            ctl_unit.reg_dst    = 0;
            ctl_unit.alu_src_1  = 0;
            ctl_unit.alu_src_2  = 0;
            ctl_unit.mem_to_reg = 0;
            ctl_unit.reg_write  = 0;
            ctl_unit.mem_read   = 0;
            ctl_unit.mem_write  = 0;
            ctl_unit.beq        = 0;
            ctl_unit.bne        = 0;
            ctl_unit.jump       = 1;
            break;

        case OP_BEQ:   
        case OP_BNE:
            ctl_unit.reg_dst    = 0;
            ctl_unit.alu_src_1  = 0;
            ctl_unit.alu_src_2  = 0;
            ctl_unit.mem_to_reg = 0;
            ctl_unit.reg_write  = 0;
            ctl_unit.mem_read   = 0;
            ctl_unit.mem_write  = 0;
            ctl_unit.beq        = (ctl_unit.opcode == OP_BEQ);
            ctl_unit.bne        = (ctl_unit.opcode == OP_BNE);
            ctl_unit.jump       = 0;
            break;

        case OP_LW:
            ctl_unit.reg_dst    = 0;
            ctl_unit.alu_src_1  = 0;
            ctl_unit.alu_src_2  = 1;
            ctl_unit.mem_to_reg = 1;
            ctl_unit.reg_write  = 1;
            ctl_unit.mem_read   = 1;
            ctl_unit.mem_write  = 0;
            ctl_unit.beq        = 0;
            ctl_unit.bne        = 0;
            ctl_unit.jump       = 0;
            break;

        case OP_SW:
            ctl_unit.reg_dst    = 0;
            ctl_unit.alu_src_1  = 0;
            ctl_unit.alu_src_2  = 1;
            ctl_unit.mem_to_reg = 0;
            ctl_unit.reg_write  = 0;
            ctl_unit.mem_read   = 0;
            ctl_unit.mem_write  = 1;
            ctl_unit.beq        = 0;
            ctl_unit.bne        = 0;
            ctl_unit.jump       = 0;
            break;

        default:
            if (ctl_unit.opcode > 0x3F) {
                printf("[ERR] Invalid opcode in control_unit - opcode : 0x%x\n", ctl_unit.opcode);

                status = FAILURE;
            }

            break;
    }

    if (status == SUCCESS)
    {
        /* Copy control-units outputs to wires */
        w_ctl_reg_dst       = ctl_unit.reg_dst;
        w_ctl_alu_src_1     = ctl_unit.alu_src_1;
        w_ctl_alu_src_2     = ctl_unit.alu_src_2;
        w_ctl_mem_to_reg    = ctl_unit.mem_to_reg;
        w_ctl_reg_write     = ctl_unit.reg_write;
        w_ctl_mem_read      = ctl_unit.mem_read;
        w_ctl_mem_write     = ctl_unit.mem_write;
        w_ctl_beq           = ctl_unit.beq;   
        w_ctl_bne           = ctl_unit.bne;   
        w_ctl_jump          = ctl_unit.jump;
    }

    return (status);
}

/*
 * alu_control_process
 * This helper function generates control signal for alu based on the function
 * field and opcode of the instruction
 */
uint8_t alu_control_process(struct alu_control *alu_ctl, uint8_t *w_alu_ctl_in)
{
    uint8_t status = SUCCESS;

    switch (alu_ctl->opcode)
    {
        case OP_RTYPE:
            /* Decision needs to be based on 'funct' field 
               as per table-4.13 of P&H */
            switch (alu_ctl->funct)
            {
                case FUNCT_ADD:
                case FUNCT_ADDU:
                    alu_ctl->alu_ctl_in = ALU_ADD;
                    break;

                case FUNCT_SUB:
                case FUNCT_SUBU:
                    alu_ctl->alu_ctl_in = ALU_SUB;
                    break;
                
                case FUNCT_AND:
                    alu_ctl->alu_ctl_in = ALU_AND;
                    break;

                case FUNCT_OR:
                    alu_ctl->alu_ctl_in = ALU_OR;
                    break;

                case FUNCT_SLT:
                case FUNCT_SLTU:
                    alu_ctl->alu_ctl_in = ALU_SLT;
                    break;

                case FUNCT_SLL:
                    alu_ctl->alu_ctl_in = ALU_SLL;
                    break;

                case FUNCT_SRL:
                    alu_ctl->alu_ctl_in = ALU_SRL;
                    break;
    
                case FUNCT_SRA:
                    alu_ctl->alu_ctl_in = ALU_SRA;
                    break;
    
                case FUNCT_XOR:
                    alu_ctl->alu_ctl_in = ALU_XOR;
                    break;

                case FUNCT_NOR:
                    alu_ctl->alu_ctl_in = ALU_NOR;
                    break;

                case FUNCT_SYSCALL:
                    /* Special Case : Halt the processor*/
                    RUN_BIT             = FALSE;
		    status              = FAILURE;
                    break;
                    
                default:
                    SIM_DEBUG(printf("Unexpected R-Type Case - Funct : 0x%x\n", alu_ctl->funct));
                    break;
            }

            break;

        /* FIXME: Use macros for the numbers below */
        case OP_ADDI:
        case OP_ADDIU:
        case OP_LW:
        case OP_SW:
            alu_ctl->alu_ctl_in = ALU_ADD;
            break;

        case OP_BEQ:   
        case OP_BNE:
            alu_ctl->alu_ctl_in = ALU_SUB;
            break;

        case OP_ANDI:
            alu_ctl->alu_ctl_in = ALU_AND;
            break;

        case OP_ORI:
            alu_ctl->alu_ctl_in = ALU_OR;
            break;

        case OP_SLTI:
        case OP_SLTIU:
            alu_ctl->alu_ctl_in = ALU_SLT;
            break;

        case OP_XORI:
            alu_ctl->alu_ctl_in = ALU_XOR;
            break;

	case OP_LUI:
	    alu_ctl->alu_ctl_in = ALU_LUI;
	    break;

        default:
            SIM_DEBUG(printf("Unexpected Opcode Case - Opcode : 0x%x\n", alu_ctl->opcode));
            break;
    }
    
    /* Assign the output of this module to the wire */
    if (status == SUCCESS) {
        *w_alu_ctl_in    = alu_ctl->alu_ctl_in;
    }

    return (status);
}
            
/*
 * multiplexor_process
 * Helper function which models a simple 2-to-1 32-bit multiplexor
 */
uint8_t multiplexor_process(struct multiplexor *mux, uint32_t *w_mux_out)
{
    uint8_t status = SUCCESS;

/*
    printf("mux (%s) -> control_signal  : 0x%x\n", mux->name, mux->control_signal);
    printf("mux (%s) -> input_0         : 0x%x\n", mux->name, mux->input_0);
    printf("mux (%s) -> input_1         : 0x%x\n", mux->name, mux->input_1);
*/
    switch (mux->control_signal)
    {
        case 0:
            //printf("mux (%s) -> case-0\n", mux->name);
            mux->output = mux->input_0;
            break;

        case 1:
            //printf("mux (%s) -> case-1\n", mux->name);
            mux->output = mux->input_1;
            break;

        default:
            printf("Invalid control-signal (%d) for mux (%s)\n", mux->control_signal, mux->name);
            status = FAILURE;
            break;
    }

    //printf("mux (%s) -> output          : 0x%x\n", mux->name, mux->output);

    if (status == SUCCESS) {
        /* Copy mux data to output wire */
        *w_mux_out = mux->output;
    }

    return (status);
}

/*
 * reg_file_process
 * Helper function which modles the register-file operations in MIPS processor
 * NOTE: The register file is read on clock-hi and written on clock-low
 */
uint8_t reg_file_process(uint8_t clock)
{
    uint8_t status = SUCCESS;
    
    /*
    SIM_DEBUG(printf("\n**********Register File Processor Invoked**********\n"));
    SIM_DEBUG(printf("read_reg_1        = 0x%x\n", reg_file.read_reg_1));
    SIM_DEBUG(printf("read_reg_2        = 0x%x\n", reg_file.read_reg_2));
    SIM_DEBUG(printf("write_reg         = 0x%x\n", reg_file.write_reg));
    SIM_DEBUG(printf("write_data        = 0x%x\n", reg_file.write_data));
    SIM_DEBUG(printf("ctl_reg_write     = 0x%x\n", reg_file.ctl_reg_write));
    SIM_DEBUG(printf("clock             = 0x%x\n", clock));
    */

    switch (clock)
    {
        case CLK_HI:
            reg_file.read_data_1 = CURRENT_STATE.REGS[reg_file.read_reg_1];
            reg_file.read_data_2 = CURRENT_STATE.REGS[reg_file.read_reg_2];
            break;

        case CLK_LO:
            if (reg_file.ctl_reg_write) {
                NEXT_STATE.REGS[reg_file.write_reg] = reg_file.write_data;
            }
            break;

        default:
            printf("[ERR] Invalid clock-state (%d) in register-file\n", clock);
            status = FAILURE;
            break;
    }

    if (status == SUCCESS) {
        /* Copy the data to the output wires of register file */
        if (CLK_HI) {
            /* Data should be read only on high clock edge */
            w_reg_file_data_1 = reg_file.read_data_1;
            w_reg_file_data_2 = reg_file.read_data_2;
        }
    }

    return (status);
}

/*
 * alu_process
 * Helper function which emulates the operation of alu
 */
uint8_t alu_process(struct alu *alu, uint32_t *w_alu_out_1, uint8_t *w_zero)
{
    uint8_t status = SUCCESS;

    switch(alu->alu_ctl)
    {
        case ALU_ADD:
            /* FIXME: Setup overflow detection */
            alu->output = alu->input_1 + alu->input_2;
            break;

        case ALU_SUB:
            alu->output = alu->input_1 - alu->input_2;
            alu->zero   = ((alu->output == 0)? 1 : 0);
            break;

        case ALU_AND:
            /* FIXME: In case of immediate, value-2 should be 0-extended */
            alu->output = alu->input_1 & alu->input_2;
            break;

        case ALU_OR:
            /* FIXME: Same as last clause */
            alu->output = alu->input_1 | alu->input_2;
            break;

        case ALU_XOR:
            /* FIXME: Same as above */
            alu->output  = alu->input_1 ^ alu->input_2;
            break;

        case ALU_NOR:
            alu->output  = ~(alu->input_1 | alu->input_2);
            break;

        case ALU_SLT:
            alu->output = ((alu->input_1 < alu->input_2)? 1 : 0);
            break;

        case ALU_SLL:
            alu->output = ((uint32_t)alu->input_2) << alu->input_1;
            break;

        case ALU_SRL:
            alu->output = ((uint32_t)alu->input_2) >> alu->input_1;
            break;

        case ALU_SRA:
            alu->output = alu->input_2 >> alu->input_1;
            break;

	case ALU_LUI:
	    alu->output = ((uint32_t)alu->input_2) << 16;
	    break;

        default:
            SIM_DEBUG(printf("Unexpected control-signal for ALU : 0x%x\n", alu->alu_ctl));
            break;
    }

    if (status == SUCCESS) {
        /* Assign the outputs of alu to wires */
        *w_alu_out_1     = alu->output;
        *w_zero          = alu->zero;
    }

    return (status);
}

/*
 * memory_process
 * Helper function which models the memory for MIPS processor
 */
uint8_t memory_process(struct memory *mem, uint32_t *w_mem_out)
{
    uint8_t status = SUCCESS;

    if (mem->ctl_mem_read == 1 && mem->ctl_mem_write == 1) {
        /* This is a fatal-error */
        status = FAILURE;
    } else if (mem->ctl_mem_read == 1) {
        /* Memory needs to be read */
        mem->output = mem_read_32(mem->address);
    } else if (mem->ctl_mem_write == 1) {
        /* Memory needs to be written */
        mem_write_32(mem->address, mem->write_data);
    } else {
        /* This is again an error since the value of controls is unexpected */
        // printf("Unexpected control signals (r : 0x%x | w : 0x%x) in memory-unit\n", mem->ctl_mem_read, mem->ctl_mem_write);
    }

    /* Write memory output to out-wire if everything has gone fine */
    if (status == SUCCESS) {
        *w_mem_out = mem->output;
    }

    return (status);
}

/*
 * sign_extend_process
 * Helper function which emulates 32-bit sign extension of 16-bit value
 */
void sign_extend_process(void)
{
    /* Perform the sign-extension */
    extend_immd.output = (int32_t)extend_immd.input;

    /* Write data to the output wire of this unit */
    w_signext_immd = (uint32_t)extend_immd.output;

    return;
}

/*
 * control_debug
 * Debug helper function which shows the output of the control unit
 */
void control_debug(void)
{
    printf("\n************** Control Unit Signals *****************\n");
    printf("opcode          : 0x%d\n", opcode);
    printf("RegDst          : %d\n", w_ctl_reg_dst);
    printf("ALUSrc1         : %d\n", w_ctl_alu_src_1);
    printf("ALUSrc2         : %d\n", w_ctl_alu_src_2);
    printf("MemtoReg        : %d\n", w_ctl_mem_to_reg);
    printf("RegWrite        : %d\n", w_ctl_reg_write);
    printf("MemRead         : %d\n", w_ctl_mem_read);
    printf("MemWrite        : %d\n", w_ctl_mem_write);
    printf("BEQ             : %d\n", w_ctl_beq);    
    printf("BNE             : %d\n", w_ctl_bne);    
    printf("Jump            : %d\n", w_ctl_jump);

    return;
}
